# This Program tests the Tax figures generated by Square. It compares tax movements to opex movements and also tests where the tax to ratio gets out of whack

import csv
import pandas as pd
import numpy as np
from pathlib import Path
import os
import re
import time
from fractions import Fraction
from IPython.core.display import display
pd.set_option('display.max_rows',  1000)
pd.set_option('display.max_columns', 100)

# Determine the first surveyed tax value for each id
def first_surv(data, variable):
    temp = data.copy()
    temp = temp[np.isnan(temp[variable]) == False]
    temp.sort_values(by=['totalmo'], ascending=True, inplace=True)
    temp = temp.drop_duplicates(['id'])
    temp = temp.set_index('id')
    temp = temp[[variable]]
    temp.columns = ['first_' + variable]
    data = data.join(temp, on = 'id')
    
    return data

# Determine the last surveyed tax value for each id and remove the periods after the last surveyed tax value, as those can be evaluated like the ids that have no tax quote at all
def last_surv(data, variable):
    temp = data.copy()
    temp = temp[np.isnan(temp[variable]) == False]
    temp.sort_values(by=['totalmo'], ascending=False, inplace=True)
    temp = temp.drop_duplicates(['id'])
    temp = temp.set_index('id')
    temp = temp[['totalmo']]
    temp.columns = ['mr_totalmo']
    data = data.join(temp, on = 'id')
    
    return data

# Calculate the surveyed tax to opex ratio, and fill it in for all intermediate periods between surveyed values
def calc_surv_ratio(data, variable):
    temp = data.copy()
    temp = temp[(np.isnan(temp[variable]) == False)]
    temp['surv_tax_ratio'] = temp[variable] / temp['op_exp']
    temp = temp[['surv_tax_ratio']]
    data = data.join(temp)
    data['surv_tax_ratio'] = np.where((data['firstrow'] == 1) & (np.isnan(data['surv_tax_ratio']) == True), 999999999, data['surv_tax_ratio'])
    data['surv_tax_ratio'] = data['surv_tax_ratio'].fillna(method='ffill')
    data['surv_tax_ratio'] = np.where(data['surv_tax_ratio'] == 999999999, np.nan, data['surv_tax_ratio'])
    
    return data

# Determine the first surveyed tax to opex ratio for each property
def first_surv_ratio(data):
    temp = data.copy()
    temp = temp[np.isnan(temp['surv_tax_ratio']) == False]
    temp.sort_values(by=['totalmo'], ascending=True, inplace=True)
    temp = temp.drop_duplicates(['id'])
    temp = temp.set_index('id')
    temp = temp[['surv_tax_ratio']]
    temp.columns = ['first_ratio']
    data = data.join(temp, on = 'id')
    
    return data

# Determine the most recent surveyed tax to opex ratio for each property
def mr_surv_ratio(data):
    temp = data.copy()
    temp = temp[np.isnan(temp['surv_tax_ratio']) == False]
    temp.sort_values(by=['totalmo'], ascending=False, inplace=True)
    temp = temp.drop_duplicates(['id'])
    temp = temp.set_index('id')
    temp = temp[['surv_tax_ratio']]
    temp.columns = ['mr_ratio']
    data = data.join(temp, on = 'id')
    
    data_after_mr = data.copy()
    data_after_mr = data_after_mr[data_after_mr['totalmo'] > data['mr_totalmo']]
    data = data[data['totalmo'] <= data['mr_totalmo']]
    
    return data, data_after_mr

# Begin modeling tax:
# First, fill in the surveyed values at each month where surveys occured
# If the first period in the historical series does not have an tax survey, then set it based on the first surveyed tax ratio.
# If there is no surveyed tax ratio for the property, then use the national average
def model_start(variable, first_surv_val, first_surv_ratio, opex, first_row, avg_tax_ratio, sd_tax_ratio):
    
    if np.isnan(variable) == False:
        modeled = variable
    elif first_row == 1:
        if np.isnan(first_surv_val) == False and first_surv_val / opex > avg_tax_ratio - sd_tax_ratio and first_surv_val / opex < avg_tax_ratio + sd_tax_ratio:
            modeled = first_surv_val
        elif np.isnan(first_surv_ratio) == False:
            modeled = opex * first_surv_ratio
        elif np.isnan(first_surv_ratio) == True:
            modeled = avg_tax_ratio * opex
        modeled = round(modeled, 2)
    else:
        modeled = np.nan

    return modeled

# Calculate the number of months between surveyed tax values per id, as well as the raw survey to survey change between those two surveys
# Use tax_m instead of re_tax, so that we can calc the smoothing periods between the first row of the series and the first survey too. At this point, tax_m should have survey values for survey periods, as well as the modeled value in only the first period row.
# Then fill in the months between surveyed tax values at each id, as well as the survey to survey change, and calculate the portion of change per period
def forward_fill(data):

    temp = data.copy()
    temp = temp[np.isnan(temp['tax_m']) == False]
    temp['months_btw_survs'] = np.where((temp['id'] == temp['id'].shift(-1)), temp['totalmo'].shift(-1) - temp['totalmo'], np.nan)
    temp['surv_to_surv_chg'] = np.where((temp['id'] == temp['id'].shift(-1)), temp['tax_m'].shift(-1) - temp['tax_m'], np.nan)
    temp = temp[['months_btw_survs', 'surv_to_surv_chg']]
    data = data.join(temp)

    data['months_btw_survs'] = data['months_btw_survs'].fillna(method='ffill')
    data['surv_to_surv_chg'] = data['surv_to_surv_chg'].fillna(method='ffill')
    data['months_btw_survs'] = np.where((data['totalmo'] > data['mr_totalmo']) | (np.isnan(data['mr_totalmo']) == True), np.nan, data['months_btw_survs'])
    data['surv_to_surv_chg'] = np.where((data['totalmo'] > data['mr_totalmo']) | (np.isnan(data['mr_totalmo']) == True), np.nan, data['surv_to_surv_chg'])
    data['surv_portion'] = data['surv_to_surv_chg'] / data['months_btw_survs']
    data['surv_portion'] = round(data['surv_portion'], 2)

    return data

# For all periods that exist between two surveyed tax values, calculate the new tax using a smoothing method that applies an even portion of the change to each month
# This could be chunked if we want to modify that even smooth assumption
def smoothing(surv_portion, variable):
    global prev_val 
    if (np.isnan(variable) == False):
        modeled = variable
        prev_val = variable
    elif (np.isnan(surv_portion) == True):
        modeled = np.nan
        prev_val = prev_val
    else:
        modeled = prev_val + surv_portion
        prev_val = modeled
    return modeled

def tax_opex_flags(sector_val, curryr, currmon, msq_data_in):

    data_in = msq_data_in.copy()
    data_in = data_in[['id', 'realid', 'yr', 'qtr', 'currmon', 'type2', 'metcode', 'subid', 'survdate', 'avrent', 're_tax', 'op_exp', 'rnt_term', 'renx', 'renxM',  'taxx', 'taxxM', 'opex', 'opexM', 'availx']]
    data_in['type2'] = np.where(data_in['type2'] == "F", "F", "DW")
    data_in['identity'] = data_in['metcode'] + data_in['subid'].astype(int).astype(str) + data_in['type2']

    # Focusing on ids that do not have a tax survey in their history first
    data = data_in.copy()
    data['firstrow'] = np.where(data['id'] != data['id'].shift(1), 1, 0)
    data['total_tax_survs'] = data.groupby('id')['re_tax'].transform('count')
    data_no_surv = data.copy()
    data_no_surv = data_no_surv[data_no_surv['total_tax_survs'] == 0]
    data = data[data['total_tax_survs'] > 0]
    data['identity_period'] = data['id'].astype(str) + data['yr'].astype(str) + data['qtr'].astype(str) + data['currmon'].astype(str) 
    data = data.set_index('identity_period')

    totalmo = pd.DataFrame(data.groupby('id').cumcount())
    totalmo.columns = ['totalmo']
    totalmo['totalmo'] = totalmo['totalmo'] + 1
    data = data.join(totalmo)

    # Set the average tax to opex ratio we would expect to see. Based on BBs work with the lease terms data
    avg_tax_ratio = 0.53
    sd_tax_ratio = 0.11

    # Call the functions to finish modeling based on opex surveys only
    data = first_surv(data, 're_tax')

    data = last_surv(data, 're_tax')

    data = calc_surv_ratio(data, 're_tax')

    data = first_surv_ratio(data)

    data, data_after_mr = mr_surv_ratio(data)

    data['tax_m'] = data.apply(lambda row: model_start(row['re_tax'], row['first_re_tax'], row['first_ratio'], row['opex'], row['firstrow'], avg_tax_ratio, sd_tax_ratio), axis=1)

    data = forward_fill(data)

    prev_val = np.nan
    data['tax_m'] = data.apply(lambda row: smoothing(row['surv_portion'], row['tax_m']), axis=1)

    data.sort_values(by=['id', 'yr', 'qtr', 'currmon'], inplace=True)

    # Calculate the difference between the current test opex values to the modeled values calculated by this code
    data['tax_diff_to_model'] = (data['tax_m'] - data['taxx']) / data['taxx']
    data['tax_diff_to_model'] = round(data['tax_diff_to_model'], 3)
    data['g_tax'] = np.where((data['id'] == data['id'].shift(1)), (data['taxx'] - data['taxx'].shift(1)) / data['taxx'].shift(1), np.nan)
    data['g_tax_m'] = np.where((data['id'] == data['id'].shift(1)), (data['tax_m'] - data['tax_m'].shift(1)) / data['tax_m'].shift(1), np.nan)
    data['g_opex'] = np.where((data['id'] == data['id'].shift(1)), (data['opex'] - data['opex'].shift(1)) / data['opex'].shift(1), np.nan)
    data['g_tax'] = round(data['g_tax'], 3)
    data['g_tax_m'] = round(data['g_tax_m'], 3)
    data['g_opex'] = round(data['g_opex'], 3)
    data['diff_direction'] = np.where((data['g_tax'] * data['g_opex'] < 0) & (data['g_tax'] * data['g_tax_m'] < 0), 1, 0)

    # Outsheet for review
    flag_cols = ['surv_to_surv_flag', 'freq_flag', 'benchmark_flag']
    aggreg_flags = pd.DataFrame()
    data_trunc = data.copy()
    data_trunc = data_trunc[['identity', 'id', 'realid', 'yr', 'qtr', 'currmon', 'metcode', 'survdate', 're_tax', 'op_exp', 'rnt_term', 'renx', 'taxx', 'opex', 'months_btw_survs', 'first_re_tax', 'surv_portion', 'surv_tax_ratio', 'first_ratio', 'mr_ratio', 'tax_m', 'tax_diff_to_model', 'g_tax', 'g_tax_m', 'g_opex', 'diff_direction']]
    data_trunc['abs_diff'] = abs(data_trunc['tax_diff_to_model'])
    data_trunc.sort_values(by=['id', 'abs_diff'], ascending=[True, False], inplace=True)
    data_trunc = data_trunc[(data_trunc['abs_diff'] > 0.05) | (data_trunc['diff_direction'] == 1)]
    data_trunc.sort_values(by=['abs_diff'], ascending=[False], inplace=True)
    data_trunc = data_trunc.drop(['abs_diff'], axis=1)
    data_trunc = data_trunc.drop_duplicates('id')
    aggreg = data_trunc.copy()
    aggreg['surv_to_surv_flag'] = 1
    aggreg = aggreg[['identity', 'id', 'yr', 'qtr', 'currmon', 'surv_to_surv_flag']]
    for x in flag_cols:
        if x not in list(aggreg.columns):
            aggreg[x] = 0
    aggreg_flags = aggreg_flags.append(aggreg, ignore_index=True)
    #data_trunc.to_pickle('/home/central/square/data/zzz-bb-test2/python/sq_redev/{}/{}m{}/OutputFiles/tax_quote_modeled_comp.pickle'.format(sector_val, curryr, currmon))

    # For properties that have never gotten an tax obs or for parts of the series that are after the last tax obs, analyze if the code is moving tax too often, and not in concert with opex
    test = data_in.copy()
    test['after_mr_tag'] = 0
    data_append = data_after_mr.copy()
    data_append.reset_index()
    data_append = data_append[list(data_in.columns)]
    data_append['after_mr_tag'] = 1
    test = test.append(data_append)
    test['ratio'] = test['taxx'] / test['opex']
    test['num_periods'] = test.groupby('id')['id'].transform('count')
    test['total_tax_survs'] = test.groupby('id')['re_tax'].transform('count')
    test = test[(test['total_tax_survs'] == 0) | (test['after_mr_tag'] == 1)]

    test['tax_chg'] = np.where((test['taxx'] != test['taxx'].shift(1)) & (test['id'] == test['id'].shift(1)), 1, 0)
    test['opex_chg'] = np.where((test['opex'] != test['opex'].shift(1)) & (test['id'] == test['id'].shift(1)), 1, 0)
    test['tax_num_chgs'] = test.groupby('id')['tax_chg'].transform('sum')
    test['opex_num_chgs'] = test.groupby('id')['opex_chg'].transform('sum')
    test['freq_tax_chgs'] = test['tax_num_chgs'] / test['num_periods']
    test['freq_opex_chgs'] = test['opex_num_chgs'] / test['num_periods']
    test['diff_chgs'] = test['tax_num_chgs'] - test['opex_num_chgs']
    test['chg_noopexchg'] = np.where((test['taxx'] != test['taxx'].shift(1)) & (test['opex'] == test['opex'].shift(1)) & (test['id'] == test['id'].shift(1)), 1, 0)
    test['totchg_noopexchg'] = test.groupby('id')['chg_noopexchg'].transform('sum')

    test = test.drop_duplicates('id')
    test = test[['identity', 'id', 'yr', 'qtr', 'currmon', 'type2', 'metcode', 'subid', 'num_periods', 'tax_num_chgs', 'opex_num_chgs', 'freq_tax_chgs', 'freq_opex_chgs', 'diff_chgs', 'totchg_noopexchg', 'after_mr_tag']]
    test.sort_values(by=['diff_chgs'], ascending = [False], inplace=True)
    aggreg = test.copy()
    aggreg = aggreg[['identity', 'id', 'yr', 'qtr', 'currmon']]
    aggreg['freq_flag'] = 1
    for x in flag_cols:
        if x not in list(aggreg.columns):
            aggreg[x] = 0
    aggreg = aggreg[['identity', 'id', 'yr', 'qtr', 'currmon'] + flag_cols]
    aggreg_flags = aggreg_flags.append(aggreg, ignore_index=True)
    #test.to_pickle('/home/central/square/data/zzz-bb-test2/python/sq_redev/{}/{}m{}/OutputFiles/tax_noquote_concessions_freq.pickle'.format(sector_val, curryr, currmon))

    # For ids that dont have any tax surveys, test if the ratio gets away from the benchmark
    test = data_in.copy()
    test['after_mr_tag'] = 0
    test['mr_ratio'] = np.nan
    data_append = data_after_mr.copy()
    data_append.reset_index()
    data_append = data_append[list(data_in.columns) + ['mr_ratio']]
    data_append['after_mr_tag'] = 1
    test = test.append(data_append)
    test['ratio'] = test['taxx'] / test['opex']
    test['total_tax_survs'] = test.groupby('id')['re_tax'].transform('count')
    test['out_of_ratio'] = np.where((test['ratio'] >= avg_tax_ratio + sd_tax_ratio) | (test['ratio'] < avg_tax_ratio - sd_tax_ratio) & (test['after_mr_tag'] == 0), 1, 0)
    test['out_of_ratio'] = np.where((test['ratio'] >= test['mr_ratio'] + 0.02) | (test['ratio'] < test['mr_ratio'] - 0.02) & (test['after_mr_tag'] == 1), 1, test['out_of_ratio'])
    test = test[(test['total_tax_survs'] == 0) | (test['after_mr_tag'] == 1)]
    test['out_of_ratio_total'] = test.groupby('id')['out_of_ratio'].transform('sum')
    test = test[test['out_of_ratio'] > 0]
    test.sort_values(by=['id', 'ratio'], ascending=[True, False], inplace=True)
    test = test.drop_duplicates('id')
    test = test[['identity', 'id', 'type2', 'metcode', 'subid', 'yr', 'qtr', 'currmon', 'ratio', 'mr_ratio', 'out_of_ratio_total', 'after_mr_tag']]
    aggreg = test.copy()
    aggreg = aggreg[['identity', 'id', 'yr', 'qtr', 'currmon']]
    aggreg['benchmark_flag'] = 1
    for x in flag_cols:
        if x not in list(aggreg.columns):
            aggreg[x] = 0
    aggreg = aggreg[['identity', 'id', 'yr', 'qtr', 'currmon'] + flag_cols]
    aggreg_flags = aggreg_flags.append(aggreg, ignore_index=True)
    #test.to_pickle('/home/central/square/data/zzz-bb-test2/python/sq_redev/{}/{}m{}/OutputFiles/tax_noquote_ratio_test.pickle'.format(sector_val, curryr, currmon))

    aggreg_flags = aggreg_flags.reset_index(drop=True)
    aggreg_flags['flag_period'] = np.where(aggreg_flags['currmon'].isnull() == True, aggreg_flags['qtr'].astype(str) + "/" + aggreg_flags['yr'].astype(str), aggreg_flags['currmon'].astype(int).astype(str) + "/" + aggreg_flags['qtr'].astype(str) + "/" + aggreg_flags['yr'].astype(str))

    for x in flag_cols:
        aggreg_flags[x] = aggreg_flags.groupby(['id', 'flag_period'])[x].transform('sum')
        aggreg_flags[x] = np.where(aggreg_flags[x] > 0, 1, 0)
    aggreg_flags = aggreg_flags.drop_duplicates(['id', 'flag_period'])
    
    aggreg_flags.sort_values(by=['identity'], ascending=[True], inplace=True)
    aggreg_flags.to_pickle('/home/central/square/data/zzz-bb-test2/python/sq_redev/{}/{}m{}/OutputFiles/to_flags.pickle'.format(sector_val, curryr, currmon))
    
    return flag_cols